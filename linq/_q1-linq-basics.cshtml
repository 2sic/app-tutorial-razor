@using System.Linq;
@using Dynlist = System.Collections.Generic.IEnumerable<dynamic>;

@{
  var persons = AsDynamic(App.Data["Persons"]);
  var books = AsDynamic(App.Data["Books"]);
}

@RenderPage("_header.cshtml")

<h2>Some notes before we start</h2>
<p>
  All our code uses some general stuff explained here:
</p>

<ul>
  <li>to enable LINQ commands we always need: <br>
  <code>@@using System.Linq</code></li>
  <li>since LINQ often can't guess object types we are using, we often need to cast lists to <code>IEnumerable&lt;dynamic&gt;</code>. Since this makes our code harder to read, so we shorted that to <code>Dynlist</code> by adding this line to the beginning of the files: <br>
  <code>@@using Dynlist = System.Collections.Generic.IEnumerable<dynamic>;</code> </li>
  <li>most of the code starts by retrieving a list of <strong>Books</strong> and <strong>Authors</strong>. This is done using: <br>
  <code>App.Data["Books"]</code></li>
  <li>Since we want to use <code>dynamic</code> types (which lets us write things like <code>book.Name</code>, we usually wrap it with: <br>
  <code>AsDynamic(App.Data["Books"])</code></li>
  <li>You'll sometimes see <code>@@RenderPage(...)</code> - this is not important for the LINQ examples, so you can ignore this for now.</li>
</ul>

<hr>

<h2>LINQ Examples</h2>

<ol>
  @TutorialLink("Access a list in list in list", "linq310")
</ol>


<ol>
  <li>Sorting 100</li>
  <li>Grouping 200</li>
  <li>Parents 300</li>
</ol>

<p>
  Learn how to leverage LINQ (Language INtegrated Query) of C# to sort, filter, group content-items. This demo uses the folloing data in app:
</p>
<ul>
  <li>Persons - various people who are used in the data. A person can also have one or many favorite books. </li>
  <li>Books - books people wrote or contributed to. Books have authors and </li>
</ul>

<hr>

<h2>Simple Sorting of Persons</h2>
<h3>OrderBy(EntityId)</h3>
<p>This example shows A-Z ordering by a property which exists on all entities: EntityId</p>
<ol>
  @foreach(var person in persons.OrderBy(p => p.EntityId)) {
    <li>@person.FirstName @person.LastName (@person.EntityId)</li>
  }
</ol>

<h3>OrderBy(FirstName)</h3>
<p>This example shows A-Z ordering by a property which exists only on Person-entities. This is simple with <code>dynamic</code> objects</p>
<ol>
  @foreach(var person in persons.OrderBy(p => p.FirstName)) {
    <li>@person.FirstName @person.LastName</li>
  }
</ol>

<h3>OrderByDescending(Birthday)</h3>
<p>This example shows Z-A ordering by a property.</p>
<ol>
  @foreach(var person in persons.OrderByDescending(p => p.Birthday)) {
    <li>@person.FirstName @person.LastName (@person.Birthday.ToString("d"))</li>
  }
</ol>



<hr>
<h2>Accessing Authors, a List inside of Books</h2>

<h3>Basic Use of List book.Authors</h3>
<p>This example shows the books, and we want to LINQ on the Authors. We must tell the compiler it's a list, so that LINQ can use <code>Select(...)</code>.</p>
<ol>
  @{
    // let's start by looping through the books
    foreach(var book in books) {
      // To work with a list coming off a dynamic object, we have to tell the compiler it's a dynamic list
      var authors = (book.Authors as Dynlist)
        .Select(a => a.FirstName + " " + a.LastName);

      <li><strong>@book.Title</strong>
        by @string.Join(", ", authors.OrderBy(ln => ln)) 
      </li>
    }
  }
</ol>

<h3>OrderBy Amount of Authors</h3>
<p>This example shows Z-A ordering, where we count the authors to sort.</p>
<ol>
  @{
    // The following example works, because p.Authors is a List, not just an IEnumerable
    // So .Count works (part of List) but Count() wouldn't work unless you cast it to Dynlist first
    foreach(var book in books.OrderByDescending(p => p.Authors.Count)) {
      var authors = (book.Authors as Dynlist).Select(a => a.FirstName + " " + a.LastName);
      <li><strong>@book.Title</strong> 
        by @string.Join(",", authors.OrderBy(ln => ln)) (@book.Authors.Count author) 
      </li>
    }
  }
</ol>



<hr>
<h2>Grouping by Authors, a List inside of Books</h2>


<h3>GroupBy Authors - bad example</h3>
<p>This example will group the books by authors. This example doesn't give us what we want, because authors that exist in sets and alone are grouped separatel. </p>
<ol>
  @foreach(var group in books.GroupBy(b => b.Authors)) {
    <li>
      Group
      <ul>
        @foreach(var book in group) {
          <li>
            <strong>@book.Title</strong> by
            @string.Join(",",(book.Authors as Dynlist).Select(a => a.FirstName + " " + a.LastName))
          </li>
        }
      </ul>
    </li>
  }
</ol>


<h3>GroupBy Authors - better example</h3>
<p>Let's do it better, and group by each Author individually</p>
<ol>
  @{ 
    var booksGroupedByAuthor = books
      .SelectMany(b => (b.Authors as Dynlist).Select(a => new { Book = b, Author = a }))
      .GroupBy(set => set.Author);
      

    
    foreach(var group in booksGroupedByAuthor) {
    <li>
      Author: @group.Key.FirstName @group.Key.LastName
      <ul>
        @foreach(var set in group) {
          <li>
            <strong>@set.Book.Title</strong> by
            @string.Join(",",(set.Book.Authors as Dynlist).Select(a => a.FirstName + " " + a.LastName))
          </li>
        }
      </ul>
    </li>
  }
  }
</ol>

<h3>GroupBy Authors - Example starting with Authors</h3>
<p>In this example, we'll start with the authors list. This is probably not ideal - as some people are not authors, but it's a good learning example. To find the books we have to navigate through <code>Parents(...)</code> because in our data-model, the books reference authors, not the authors to books.</p>
<ol>
  @foreach(var author in persons) {
    // this line would work, if Books only had people in the Authors. 
    // but it doesn't, there are also illustrators, which is why we use the second example instead
    var peoplesBooks = author.Parents("Books");
    var authorsBooks = author.Parents("Books", "Authors");

    <li>
      @author.FirstName @author.LastName
      <ul>
        @foreach(var book in authorsBooks) {
          var coAuthors = (book.Authors as Dynlist).Where(a => a != author);
          <li>
            <strong>@book.Title</strong> 
            @if(coAuthors.Any()) {
              <span>co-authored by 
                @string.Join(",", coAuthors.Select(a => a.FirstName + " " + a.LastName))
              </span>
            }
          </li>
        }
      </ul>
    </li>
  }
</ol>

