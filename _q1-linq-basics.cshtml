@* These lines are comments, surrounded by * and @ *@
@* @using... means that we're going to access .net commands from these namespaces *@
@using System.Linq;
@using ToSic.SexyContent;
@* This is a short-notation we use a lot, so it's declared here *@
@using Dynlist = System.Collections.Generic.IEnumerable<dynamic>;

@{
  // the following code retrieves data from the app directly - so this is like reading a table of data
  // note we're converting them to dynamic, for easier access to properties like person.Name etc.
  var persons = AsDynamic(App.Data["Persons"]);
  var books = AsDynamic(App.Data["Books"]);
}

<h1>LINQ Basics</h1>
<p>
  Learn how to leverage LINQ (Language INtegrated Query) of C# to sort, filter, group content-items. This demo uses the folloing data in app:
</p>
<ul>
  <li>Persons - various people who are used in the data. A person can also have one or many favorite books. </li>
  <li>Books - books people wrote or contributed to. Books have authors and </li>
</ul>

<hr>

<h2>Simple Sorting of Persons</h2>
<h3>OrderBy(EntityId)</h3>
<p>This example shows A-Z ordering by a property which exists on all entities: EntityId</p>
<ol>
  @foreach(var person in persons.OrderBy(p => p.EntityId)) {
    <li>@person.FirstName @person.LastName (@person.EntityId)</li>
  }
</ol>

<h3>OrderBy(FirstName)</h3>
<p>This example shows A-Z ordering by a property which exists only on Person-entities. This is simple with <code>dynamic</code> objects</p>
<ol>
  @foreach(var person in persons.OrderBy(p => p.FirstName)) {
    <li>@person.FirstName @person.LastName</li>
  }
</ol>

<h3>OrderByDescending(Birthday)</h3>
<p>This example shows Z-A ordering by a property.</p>
<ol>
  @foreach(var person in persons.OrderByDescending(p => p.Birthday)) {
    <li>@person.FirstName @person.LastName (@person.Birthday.ToString("d"))</li>
  }
</ol>



<hr>
<h2>Accessing Authors, a List inside of Books</h2>

<h3>Basic Use of List book.Authors</h3>
<p>This example shows the books, and we want to LINQ on the Authors. We must tell the compiler it's a list, so that LINQ can use <code>Select(...)</code>.</p>
<ol>
  @{
    // let's start by looping through the books
    foreach(var book in books) {
      // To work with a list coming off a dynamic object, we have to tell the compiler it's a dynamic list
      var authors = (book.Authors as Dynlist)
        .Select(a => a.FirstName + " " + a.LastName);

      <li><strong>@book.Title</strong>
        by @string.Join(", ", authors.OrderBy(ln => ln)) 
      </li>
    }
  }
</ol>

<h3>OrderBy Amount of Authors</h3>
<p>This example shows Z-A ordering, where we count the authors to sort.</p>
<ol>
  @{
    // The following example works, because p.Authors is a List, not just an IEnumerable
    // So .Count works (part of List) but Count() wouldn't work unless you cast it to Dynlist first
    foreach(var book in books.OrderByDescending(p => p.Authors.Count)) {
      var authors = (book.Authors as Dynlist).Select(a => a.FirstName + " " + a.LastName);
      <li><strong>@book.Title</strong> 
        by @string.Join(",", authors.OrderBy(ln => ln)) (@book.Authors.Count author) 
      </li>
    }
  }
</ol>



<hr>
<h2>Grouping by Authors, a List inside of Books</h2>


<h3>GroupBy Authors - bad example</h3>
<p>This example will group the books by authors. This example doesn't give us what we want, because authors that exist in sets and alone are grouped separatel. </p>
<ol>
  @foreach(var group in books.GroupBy(b => b.Authors)) {
    <li>
      Group
      <ul>
        @foreach(var book in group) {
          <li>
            <strong>@book.Title</strong> by
            @string.Join(",",(book.Authors as Dynlist).Select(a => a.FirstName + " " + a.LastName))
          </li>
        }
      </ul>
    </li>
  }
</ol>


<h3>GroupBy Authors - better example</h3>
<p>Let's do it better, and group by each Author individually</p>
<ol>
  @{ 
    var booksGroupedByAuthor = books
      .SelectMany(b => (b.Authors as Dynlist).Select(a => new { Book = b, Author = a }))
      .GroupBy(set => set.Author);
      

    
    foreach(var group in booksGroupedByAuthor) {
    <li>
      Author: @group.Key.FirstName @group.Key.LastName
      <ul>
        @foreach(var set in group) {
          <li>
            <strong>@set.Book.Title</strong> by
            @string.Join(",",(set.Book.Authors as Dynlist).Select(a => a.FirstName + " " + a.LastName))
          </li>
        }
      </ul>
    </li>
  }
  }
</ol>

<h3>GroupBy Authors - Example starting with Authors</h3>
<p>In this example, we'll start with the authors list. This is probably not ideal - as some people are not authors, but it's a good learning example. To find the books we have to navigate through <code>Parents(...)</code> because in our data-model, the books reference authors, not the authors to books.</p>
<ol>
  @foreach(var author in persons) {
    var authorsBooks = author.Parents("Books");
    <li>
      Author: @author.FirstName @author.LastName
      <ul>
        @foreach(var book in authorsBooks) {
          var coAuthors = (book.Authors as Dynlist).Where(a => a != author);
          <li>
            <strong>@book.Title</strong> 
            @if(coAuthors.Any()) {
              <span>co-authored by 
                @string.Join(",", coAuthors.Select(a => a.FirstName + " " + a.LastName))
              </span>
            }
          </li>
        }
      </ul>
    </li>
  }
</ol>


<hr>
<h2>Accessing Books.Authors.Awards, a List in a List in a List</h2>

<h3>Show only books of Awarded Authors #1</h3>
<p>This example first gets book, checks the authors and checks if they have awards with LINQ <code>Any()</code>. </p>
@{
  var booksWithAwardedAuthors = books
    .Where(b => (b.Authors as Dynlist)
    .SelectMany(a => a.Awards as Dynlist) // this gets all the awards and "flattens" the list
    .Any());
}
<ol>
  @foreach(var book in booksWithAwardedAuthors) {
    var awards = (book.Authors as Dynlist).SelectMany(a => (a.Awards as Dynlist));
    <li><strong>@book.Title</strong> 
      with @string.Join(",", awards.Select(a => a.Name)) (@awards.Count() awards) 
    </li>
  }
</ol>
<p>And now the opposite list, so all books which don't contain one of the books with authors. It gets the "other" books by filtering the list to exclude the ones it found first. That demonstrates how to use <code>Contains(x as object)</code>. The <code>Contains(...)</code> cannot work with <code>dynamic</code>, so we must tell it it's an object for it to work.</p>
@{
  var otherBooks = books
    .Where(b => !(booksWithAwardedAuthors as Dynlist)
    .Contains(b as object));              // important: Contains only works correctly on dynamics in 2sxc 9.42+
}
<ol>
  @foreach(var book in otherBooks) {
    <li><strong>@book.Title</strong></li>
  }
</ol>
<p>Now let's do the same, but using <code>GroupBy</code> to group by awarded authors and not-awarded authors:</p>
@{
  var booksGroupedByAuthorAwards = books
    .GroupBy(b => ((b.Authors as Dynlist).SelectMany(a => a.Awards as Dynlist).Any()));
}
<ul>
  @foreach(var group in booksGroupedByAuthorAwards) {
    <li>Authors with Awards: @group.Key</li>
  }
</ul>