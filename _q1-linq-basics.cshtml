@* These lines are comments, surrounded by * and @ *@
@* @using... means that we're going to access .net commands from these namespaces *@
@using System.Linq;
@using ToSic.SexyContent;
@* This is a short-notation we use a lot, so it's declared here *@
@using Dynlist = System.Collections.Generic.IEnumerable<dynamic>;

@{
  // the following code retrieves data from the app directly - so this is like reading a table of data
  // note that they are lists of the type IEntity and not dynamic items
  // this allows us to use LINQ easily, but doesn't allow writing person.Name, as that needs a dynamic object
  // you'll see how this is converted as needed below
  var books = App.Data["Books"];
  var persons = App.Data["Persons"];// AsDynamic(App.Data["Persons"];

  var personList = AsDynamic(App.Data["Persons"]);
  var bookList = AsDynamic(App.Data["Books"]);
}

<h1>LINQ Basics</h1>
<p>
  Learn how to leverage LINQ (Language INtegrated Query) of C# to sort, filter, group content-items. This demo uses the folloing data in app:
</p>
<ul>
  <li>Persons - various people who are used in the data. A person can also have one or many favorite books. </li>
  <li>Books - books people wrote or contributed to. Books have authors and </li>
</ul>

<hr>

<h2>Simple Sorting of Persons</h2>
<h3>OrderBy(EntityId)</h3>
<p>This example shows A-Z ordering by a property which exists on all entities: EntityId</p>
<ol>
  @foreach(var person in personList.OrderBy(p => p.EntityId)) {
    <li>@person.FirstName @person.LastName (@person.EntityId)</li>
  }
</ol>

<h3>OrderBy(FirstName)</h3>
<p>This example shows A-Z ordering by a property which exists only on Person-entities. This is simple with <code>dynamic</code> objects</p>
<ol>
  @foreach(var person in personList.OrderBy(p => p.FirstName)) {
    <li>@person.FirstName @person.LastName</li>
  }
</ol>

<h3>OrderByDescending(Birthday)</h3>
<p>This example shows Z-A ordering by a property.</p>
<ol>
  @foreach(var person in personList.OrderByDescending(p => p.Birthday)) {
    <li>@person.FirstName @person.LastName (@person.Birthday.ToString("d"))</li>
  }
</ol>



<hr>

<h2>Advanced Sorting of Books</h2>

<h3>Basic OrderBy Title</h3>
<p>This example shows the books, and we want to LINQ on the Authors. This doesn't with with <code>dynamic</code> because LINQ doesn't know that it can use <code>Select(...)</code>.</p>
<ol>
  @{
    // let's start by looping through the books
    foreach(var b in books) {
      // this is the safest way to get all the names of the authors
      // the Children(...) method returns a properly typed list of the authors, allowing us to use Select(...)
      // the downside is that we don't have dynamic objects, so instead of a.LastName we must write a.Value("LastName")
      // var authors = b.Children("Authors").Select(a => a.Value("LastName"));

      // let's create a dynamic object to work with, so we can write book.Title in the template below
      var book = AsDynamic(b);
      
      // just fyi: the following wouldn't work - you would get an error "Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type"
      // var authors = book.Authors.Select(a => a.FirstName + " " + a.LastName);
      // wheras this works, because we explicitly say that book.Authors is an IEnumerable
      var authors = (book.Authors as Dynlist).Select(a => a.LastName);

      var y = (Dynlist)book.Autors;

      <li><strong>@book.Title</strong> by 
        @string.Join(", ", authors.OrderBy(ln => ln)) 

      </li>
    }
  }
</ol>

<h3>OrderBy Amount of Authors</h3>
<p>This example shows A-Z ordering, where we count the authors to sort. This is special, because LINQ statements like <code>Count()</code> only work, if the compiler knows what type it's working with.</p>
<ol>
  @{
    // this wouldn't work, so it's commented out
    // the reason is that .Count() is a special extension method, for which the compiler
    // must know that it's about to process a list. 
    // foreach(var book in AsDynamic(books).OrderByDescending(p => p.Authors.Count())) {
    //
    // so the better solution is to sort first, and surround all of it with AsDynamic
    // since the core Entity type doesn't have a .Authors, we must use Children("Authors")
    foreach(var book in AsDynamic(books.OrderByDescending(p => p.Children("Authors").Count()))) {
      <li><strong>@book.Title</strong> by @string.Join(",", book.Authors) (@book.Authors.Count author) </li>
    }
  }
</ol>


@functions{

  string x(object y) {
    return "";
  }

  IEnumerable<dynamic> AsList(dynamic original) {
    return original as IEnumerable<dynamic>;
  }
}